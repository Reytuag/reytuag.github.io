<!doctype html>
<meta charset="utf-8">
<script src="template.v1.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous">

    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js" integrity="sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp" crossorigin="anonymous"></script>

    <!-- To automatically render math in text elements, include the auto-render extension: -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>
<script type="text/front-matter">
  title: "Learning Sensorimotor Capabilities in Cellular Automata"
  description: "Description of the post"
  authors:
  - Chris Olah: http://colah.github.io
  - Shan Carter: http://shancarter.com
  affiliations:
  - Google Brain: http://g.co/brain
  - Google Brain: http://g.co/brain
</script>
<style>
#showText {opacity:0.75; background-color:#668; color:#eef; font:0.7em Courier New; }
</style>

<dt-article  >
  <h1>Learning Sensorimotor Capabilities in Cellular Automata</h1>
  <h2> Learning robust creatures </h2>


  <canvas id="glCanvas" class="l-middle-outset" width="640" height="360" ></canvas>
  <!--shadertoy at mac 840x472, at win 640x360-->
  <div id="showText" onclick="this.style.display='none';">initializing...</div>

  <script type="text/javascript" src="utils.js"></script>
  <script type="text/javascript">
  "use strict";

  window.onload = init;

  const canvas = document.getElementById("glCanvas");
  const textbox = document.getElementById("showText");
  const gl = canvas.getContext("webgl2", { antialias:false });
  textbox.innerHTML = "initializing global...";

  const url = new URL(window.location.href);
  const isMobile = checkMobile();
  const filename = getParam("file", "string", "lenia4param", "lenia4param");
  const shadertoyFilename =   filename + ".glsl";  // error line number - 31
  var randomSpecies = Math.floor(new Date().getSeconds() / 60 * 10); //Math.floor(Math.random() * 9);
  var initSpecies = getParam("species", "int", randomSpecies, randomSpecies);
  //const targetFPS = 60;
  const stepsPerFrame = getParam("step", "int", 1, 1);
  const useWindowSize = getParam("resize", "bool", false, true);
  const useLogicalPixel = getParam("pixel", "bool", false, true);
  const pixelSize = useLogicalPixel ? getParam("pixel", "int", 1, 5) : 1/(window.devicePixelRatio || 1);
  // https://www.khronos.org/webgl/wiki/HandlingHighDPI
  // https://mydevice.io

  const glNotFoundRedirect = "https://caniuse.com/webgl2";
  const canvasFilter = gl.LINEAR;  // gl.NEAREST or gl.LINEAR
  const canvasWrap = gl.REPEAT;  // gl.REPEAT or gl.CLAMP_TO_EDGE

  var width, height;
  var simProgram, drawProgram;
  var uniforms, params;
  var framebufferA, framebufferB, textureA, textureB;
  var frameFlip = false;

  var pause = false;
  var gen, frame;
  var startTime;
  var lastTime;
  var lastFPSGen;
  var lastFPSTime;
  var actualFPS = 0;
  var speciesName = "";

  function setSpecies(species) {
  	//gl.uniform1f(params.R, 12.);  // space resolution = kernel radius
  	gl.uniform1f(params.T, 2.);  // time resolution = number of divisions per unit time
  	switch (species) {
  		case 0:
  		speciesName = "VT049W fission";  // Tessellatium (sometimes reproductive)
  		gl.uniform1f(params.baseNoise, 0.10);
  		gl.uniformMatrix4fv(params.betaLen, false, [1., 1., 2., 2., 1., 2., 1., 1., 1., 2., 2., 2., 1., 2., 1., 0.] );  // kernel ring number
  		gl.uniformMatrix4fv(params.beta0,   false, [1., 1., 1., 0., 1., 5./6., 1., 1., 1., 11./12., 3./4., 11./12., 1., 1./6., 1., 0.] );  // kernel ring heights
  		gl.uniformMatrix4fv(params.beta1,   false, [0., 0., 1./4., 1., 0., 1., 0., 0., 0., 1., 1., 1., 0., 1., 0., 0.] );
  		gl.uniformMatrix4fv(params.beta2,   false, [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.] );
  		gl.uniformMatrix4fv(params.mu,      false, [0.272, 0.349, 0.2, 0.114, 0.447, 0.247, 0.21, 0.462, 0.446, 0.327, 0.476, 0.379, 0.262, 0.412, 0.201, 0.] );  // growth center
  		gl.uniformMatrix4fv(params.sigma,   false, [0.0595, 0.1585, 0.0332, 0.0528, 0.0777, 0.0342, 0.0617, 0.1192, 0.1793, 0.1408, 0.0995, 0.0697, 0.0877, 0.1101, 0.0786, 1.] );  // growth width
  		gl.uniformMatrix4fv(params.eta,     false, [0.19, 0.66, 0.39, 0.38, 0.74, 0.92, 0.59, 0.37, 0.94, 0.51, 0.77, 0.92, 0.71, 0.59, 0.41, 0.] );  // growth strength
  		gl.uniformMatrix4fv(params.relR,    false, [0.91, 0.62, 0.5, 0.97, 0.72, 0.8, 0.96, 0.56, 0.78, 0.79, 0.5, 0.72, 0.68, 0.55, 0.82, 1.] );  // relative kernel radius
  		break;
  		case 1:
  		speciesName = "Z18A9R reproductive";  // Tessellatium (highly reproductive) (modified for lower reproduction)
  		gl.uniform1f(params.baseNoise, 0.07);
  		gl.uniformMatrix4fv(params.betaLen, false, [1., 1., 2., 2., 1., 2., 1., 1., 1., 2., 2., 2., 1., 2., 1., 0.] );  // kernel ring number
  		gl.uniformMatrix4fv(params.beta0,   false, [1., 1., 1., 0., 1., 3./4., 1., 1., 1., 11./12., 3./4., 1., 1., 1./4., 1., 0.] );  // kernel ring heights
  		gl.uniformMatrix4fv(params.beta1,   false, [0., 0., 1./4., 1., 0., 1., 0., 0., 0., 1., 1., 11./12., 0., 1., 0., 0.] );
  		gl.uniformMatrix4fv(params.beta2,   false, [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.] );
  		gl.uniformMatrix4fv(params.mu,      false, [0.175, 0.382, 0.231, 0.123, 0.398, 0.224, 0.193, 0.512, 0.427, 0.286, 0.508, 0.372, 0.196, 0.371, 0.246, 0.] );  // growth center
  		gl.uniformMatrix4fv(params.sigma,   false, [0.0682, 0.1568, 0.034, 0.0484, 0.0816, 0.0376, 0.063, 0.1189, 0.1827, 0.1422, 0.1079, 0.0724, 0.0934, 0.1107, 0.0672, 1.] );  // growth width
  		gl.uniformMatrix4fv(params.eta,     false, [0.138, 0.544, 0.326, 0.256, 0.544, 0.544, 0.442, 0.198, 0.58, 0.282, 0.396, 0.618, 0.382, 0.374, 0.376, 0.] );  // growth strength
  		gl.uniformMatrix4fv(params.relR,    false, [0.78, 0.56, 0.6, 0.84, 0.76, 0.82, 1.0, 0.68, 0.99, 0.72, 0.56, 0.65, 0.85, 0.54, 0.82, 1.] );  // relative kernel radius
  		//gl.uniformMatrix4fv(params.sigma,   false, 0.0682, 0.1568, 0.034, 0.0484, 0.0816, 0.0376, 0.063, 0.1189, 0.1827, 0.1422, 0.1079, 0.0724, 0.0934, 0.1107, 0.0712, 1.] );  // growth width
  		break;
  		case 2:
  		speciesName = "G6G6CR ciliates";  // Ciliatium (immune system) (modified for higher cilia production)
  		gl.uniform1f(params.baseNoise, 0.09);
  		gl.uniformMatrix4fv(params.betaLen, false, [1., 1., 1., 2., 1., 2., 1., 1., 1., 1., 1., 2., 1., 1., 2., 0.] );  // kernel ring number
  		gl.uniformMatrix4fv(params.beta0,   false, [1., 1., 1., 1./12., 1., 5./6., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0.] );  // kernel ring heights
  		gl.uniformMatrix4fv(params.beta1,   false, [0., 0., 0., 1., 0., 1., 0., 0., 0., 0., 0., 11./12., 1., 0., 0., 0.] );
  		gl.uniformMatrix4fv(params.beta2,   false, [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.] );
  		gl.uniformMatrix4fv(params.mu,      false, [0.118, 0.174, 0.244, 0.114, 0.374, 0.222, 0.306, 0.449, 0.498, 0.295, 0.43, 0.353, 0.238, 0.39, 0.1, 0.] );  // growth center
  		gl.uniformMatrix4fv(params.sigma,   false, [0.0639, 0.159, 0.0287, 0.0469, 0.0822, 0.0294, 0.0775, 0.124, 0.1836, 0.1373, 0.0999, 0.0954, 0.0995, 0.1114, 0.0601, 1.] );  // growth width
  		gl.uniformMatrix4fv(params.eta,     false, [0.082, 0.462, 0.496, 0.27, 0.518, 0.576, 0.324, 0.306, 0.544, 0.374, 0.33, 0.528, 0.498, 0.43, 0.26, 0.] );  // growth strength
  		gl.uniformMatrix4fv(params.relR,    false, [0.85, 0.61, 0.5, 0.81, 0.85, 0.93, 0.88, 0.74, 0.97, 0.92, 0.56, 0.56, 0.95, 0.59, 0.58, 1.] );  // relative kernel radius
  		//gl.uniformMatrix4fv(params.sigma,   false, [0.0639, 0.159, 0.0287, 0.0469, 0.0822, 0.0294, 0.0775, 0.124, 0.1836, 0.1373, 0.0999, 0.0754, 0.0995, 0.1144, 0.0601, 1.] );  // growth width
  		break;
  		case 3:
  		speciesName = "tri-color ghosts";
  		gl.uniform1f(params.baseNoise, 0.08);
  		gl.uniformMatrix4fv(params.betaLen, false, [2., 3., 1., 2., 3., 1., 2., 3., 1., 0., 0., 0., 0., 0., 0., 0.] );  // kernel ring number
  		gl.uniformMatrix4fv(params.beta0,   false, [1./4., 1., 1., 1./4., 1., 1., 1./4., 1., 1., 0., 0., 0., 0., 0., 0., 0.] );  // kernel ring heights
  		gl.uniformMatrix4fv(params.beta1,   false, [1., 3./4., 0., 1., 3./4., 0., 1., 3./4., 0., 0., 0., 0., 0., 0., 0., 0.] );
  		gl.uniformMatrix4fv(params.beta2,   false, [0., 3./4., 0., 0., 3./4., 0., 0., 3./4., 0., 0., 0., 0., 0., 0., 0., 0.] );
  		gl.uniformMatrix4fv(params.mu,      false, [0.16, 0.22, 0.28, 0.16, 0.22, 0.28, 0.16, 0.22, 0.28, 0., 0., 0., 0., 0., 0., 0.] );  // growth center
  		gl.uniformMatrix4fv(params.sigma,   false, [0.025, 0.042, 0.025, 0.025, 0.042, 0.025, 0.025, 0.042, 0.025, 1., 1., 1., 1., 1., 1., 1.] );  // growth width
  		gl.uniformMatrix4fv(params.eta,     false, [0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0., 0., 0., 0., 0., 0., 0.] );  // growth strength
  		gl.uniformMatrix4fv(params.relR,    false, [1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.] );  // relative kernel radius
  		break;
  		case 4:
  		speciesName = "KH97WU courting";  // Tessellatium (courting, slightly reproductive)";
  		gl.uniform1f(params.baseNoise, 0.14);
  		gl.uniformMatrix4fv(params.betaLen, false, [1., 1., 2., 2., 1., 2., 1., 1., 1., 2., 2., 1., 1., 2., 1., 0.] );  // kernel ring number
  		gl.uniformMatrix4fv(params.beta0,   false, [1., 1., 1., 0., 1., 5./6., 1., 1., 1., 11./12., 3./4., 1., 1., 1./6., 1., 0.] );  // kernel ring heights
  		gl.uniformMatrix4fv(params.beta1,   false, [0., 0., 1./4., 1., 0., 1., 0., 0., 0., 1., 1., 0., 0., 1., 0., 0.] );
  		gl.uniformMatrix4fv(params.beta2,   false, [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.] );
  		gl.uniformMatrix4fv(params.mu,      false, [0.204, 0.359, 0.176, 0.128, 0.386, 0.229, 0.181, 0.466, 0.466, 0.37, 0.447, 0.391, 0.299, 0.398, 0.183, 0.] );  // growth center
  		gl.uniformMatrix4fv(params.sigma,   false, [0.0574, 0.152, 0.0314, 0.0545, 0.0825, 0.0348, 0.0657, 0.1224, 0.1789, 0.1372, 0.1064, 0.0644, 0.0891, 0.1065, 0.0773, 1.] );  // growth width
  		gl.uniformMatrix4fv(params.eta,     false, [0.116, 0.448, 0.332, 0.392, 0.398, 0.614, 0.448, 0.224, 0.624, 0.352, 0.342, 0.634, 0.362, 0.472, 0.242, 0.] );  // growth strength
  		gl.uniformMatrix4fv(params.relR,    false, [0.93, 0.59, 0.58, 0.97, 0.79, 0.87, 1.0, 0.64, 0.67, 0.68, 0.5, 0.85, 0.69, 0.87, 0.66, 1.] );  // relative kernel radius
  		break;
  		case 5:
  		speciesName = "XEH4YR explosive";  // Tessellatium (explosive)";
  		gl.uniform1f(params.baseNoise, 0.10);
  		gl.uniformMatrix4fv(params.betaLen, false, [1., 1., 2., 2., 1., 2., 1., 1., 1., 2., 2., 2., 1., 3., 1., 0.] );  // kernel ring number
  		gl.uniformMatrix4fv(params.beta0,   false, [1., 1., 1., 0., 1., 5./6., 1., 1., 1., 11./12., 3./4., 11./12., 1., 1./6., 1., 0.] );  // kernel ring heights
  		gl.uniformMatrix4fv(params.beta1,   false, [0., 0., 1./4., 1., 0., 1., 0., 0., 0., 1., 1., 1., 0., 1., 0., 0.] );
  		gl.uniformMatrix4fv(params.beta2,   false, [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.] );
  		gl.uniformMatrix4fv(params.mu,      false, [0.282, 0.354, 0.197, 0.164, 0.406, 0.251, 0.259, 0.517, 0.455, 0.264, 0.472, 0.417, 0.208, 0.395, 0.184, 0.] );  // growth center
  		gl.uniformMatrix4fv(params.sigma,   false, [0.0646, 0.1584, 0.0359, 0.056, 0.0738, 0.0383, 0.0665, 0.1164, 0.1806, 0.1437, 0.0939, 0.0666, 0.0815, 0.1049, 0.0748, 1.] );  // growth width
  		gl.uniformMatrix4fv(params.eta,     false, [0.082, 0.544, 0.26, 0.294, 0.508, 0.56, 0.326, 0.21, 0.638, 0.346, 0.384, 0.748, 0.44, 0.366, 0.294, 0.] );  // growth strength
  		gl.uniformMatrix4fv(params.relR,    false, [0.85, 0.62, 0.69, 0.84, 0.82, 0.86, 1.0, 0.5, 0.78, 0.6, 0.5, 0.7, 0.67, 0.6, 0.8, 1.] );  // relative kernel radius
  		break;
  		case 6:
  		speciesName = "HAESRE zigzagging";  // Tessellatium (zigzaging)";
  		gl.uniform1f(params.baseNoise, 0.13);
  		gl.uniformMatrix4fv(params.betaLen, false, [1., 1., 2., 2., 1., 2., 1., 1., 1., 2., 2., 2., 1., 2., 1., 0.] );  // kernel ring number
  		gl.uniformMatrix4fv(params.beta0,   false, [1., 1., 1., 0., 1., 3./4., 1., 1., 1., 11./12., 5./6., 1., 1., 1./4., 1., 0.] );  // kernel ring heights
  		gl.uniformMatrix4fv(params.beta1,   false, [0., 0., 1./4., 1., 0., 1., 0., 0., 0., 1., 1., 11./12., 0., 1., 0., 0.] );
  		gl.uniformMatrix4fv(params.beta2,   false, [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.] );
  		gl.uniformMatrix4fv(params.mu,      false, [0.272, 0.337, 0.129, 0.132, 0.429, 0.239, 0.25, 0.497, 0.486, 0.276, 0.425, 0.352, 0.21, 0.381, 0.244, 0.] );  // growth center
  		gl.uniformMatrix4fv(params.sigma,   false, [0.0674, 0.1576, 0.0382, 0.0514, 0.0813, 0.0409, 0.0691, 0.1166, 0.1751, 0.1344, 0.1026, 0.0797, 0.0921, 0.1056, 0.0813, 1.] );  // growth width
  		gl.uniformMatrix4fv(params.eta,     false, [0.15, 0.474, 0.342, 0.192, 0.524, 0.598, 0.426, 0.348, 0.62, 0.338, 0.314, 0.608, 0.292, 0.426, 0.346, 0.] );  // growth strength
  		gl.uniformMatrix4fv(params.relR,    false, [0.87, 0.65, 0.67, 0.98, 0.77, 0.83, 1.0, 0.7, 0.99, 0.69, 0.7, 0.57, 0.89, 0.84, 0.76, 1.] );  // relative kernel radius
  		break;
  		case 7:
  		speciesName = "GDNQYX variety";  // Tessellatium (stable)";
  		gl.uniform1f(params.baseNoise, 0.13);
  		gl.uniformMatrix4fv(params.betaLen, false, [1., 1., 2., 2., 1., 2., 1., 1., 1., 2., 2., 2., 1., 2., 1., 0.] );  // kernel ring number
  		gl.uniformMatrix4fv(params.beta0,   false, [1., 1., 1., 0., 1., 5./6., 1., 1., 1., 11./12., 3./4., 1., 1., 1./6., 1., 0.] );  // kernel ring heights
  		gl.uniformMatrix4fv(params.beta1,   false, [0., 0., 1./4., 1., 0., 1., 0., 0., 0., 1., 1., 11./12., 0., 1., 0., 0.] );
  		gl.uniformMatrix4fv(params.beta2,   false, [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.] );
  		gl.uniformMatrix4fv(params.mu,      false, [0.242, 0.375, 0.194, 0.122, 0.413, 0.221, 0.192, 0.492, 0.426, 0.361, 0.464, 0.361, 0.235, 0.381, 0.216, 0.] );  // growth center
  		gl.uniformMatrix4fv(params.sigma,   false, [0.061, 0.1553, 0.0361, 0.0531, 0.0774, 0.0365, 0.0649, 0.1219, 0.1759, 0.1381, 0.1044, 0.0686, 0.0924, 0.1118, 0.0748, 1.] );  // growth width
  		gl.uniformMatrix4fv(params.eta,     false, [0.144, 0.506, 0.332, 0.3, 0.502, 0.58, 0.344, 0.268, 0.582, 0.326, 0.418, 0.642, 0.39, 0.378, 0.294, 0.] );  // growth strength
  		gl.uniformMatrix4fv(params.relR,    false, [0.98, 0.59, 0.5, 0.93, 0.73, 0.88, 0.93, 0.61, 0.84, 0.7, 0.57, 0.73, 0.74, 0.87, 0.72, 1.] );  // relative kernel radius
  		break;
  		case 8:
  		speciesName = "Y3CS55 emitter";  // Papillatium (fast emitter)";
  		gl.uniform1f(params.baseNoise, 0.10);
  		gl.uniformMatrix4fv(params.betaLen, false, [1., 1., 1., 2., 1., 2., 1., 1., 1., 1., 1., 3., 1., 1., 2., 0.] );  // kernel ring number
  		gl.uniformMatrix4fv(params.beta0,   false, [1., 1., 1., 1./12., 1., 5./6., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0.] );  // kernel ring heights
  		gl.uniformMatrix4fv(params.beta1,   false, [0., 0., 0., 1., 0., 1., 0., 0., 0., 0., 0., 11./12., 0., 0., 1./12., 0.] );
  		gl.uniformMatrix4fv(params.beta2,   false, [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.] );
  		gl.uniformMatrix4fv(params.mu,      false, [0.168, 0.1, 0.265, 0.111, 0.327, 0.223, 0.293, 0.465, 0.606, 0.404, 0.377, 0.297, 0.319, 0.483, 0.1, 0.] );  // growth center
  		gl.uniformMatrix4fv(params.sigma,   false, [0.062, 0.1495, 0.0488, 0.0555, 0.0763, 0.0333, 0.0724, 0.1345, 0.1807, 0.1413, 0.1136, 0.0701, 0.1038, 0.1185, 0.0571, 1.] );  // growth width
  		gl.uniformMatrix4fv(params.eta,     false, [0.076, 0.562, 0.548, 0.306, 0.568, 0.598, 0.396, 0.298, 0.59, 0.396, 0.156, 0.426, 0.558, 0.388, 0.132, 0.] );  // growth strength
  		gl.uniformMatrix4fv(params.relR,    false, [0.58, 0.68, 0.5, 0.87, 1.0, 1.0, 0.88, 0.88, 0.86, 0.98, 0.63, 0.53, 1.0, 0.89, 0.59, 1.] );  // relative kernel radius
  		break;
  		case 9:
          speciesName = "F45LYC cloud";
  		gl.uniform1f(params.baseNoise, 0.09);
          gl.uniformMatrix4fv(params.betaLen, false, [3., 2., 1., 3., 2., 1., 3., 2., 1., 2., 1., 1., 2., 2., 1., 0.] );  // kernel ring number
          gl.uniformMatrix4fv(params.beta0,   false, [1., 2./3., 1., 1., 5./12., 1., 1., 1./6., 1., 1./6., 1., 1., 7./12., 1./4., 1., 0.] );  // kernel ring heights
          gl.uniformMatrix4fv(params.beta1,   false, [1./4., 1., 0., 1./12., 1., 0., 1./12., 1., 0., 1., 0., 0., 1., 1., 0., 0.] );
          gl.uniformMatrix4fv(params.beta2,   false, [11./12., 0., 0., 2./3., 0., 0., 7./12., 0., 0., 0., 0., 0., 0., 0., 0., 0.] );
          gl.uniformMatrix4fv(params.mu,      false, [0.151, 0.217, 0.249, 0.358, 0.243, 0.463, 0.145, 0.181, 0.31, 0.116, 0.326, 0.68, 0.276, 0.242, 0.119, 0.] );  // growth center
          gl.uniformMatrix4fv(params.sigma,   false, [0.0176, 0.0693, 0.0606, 0.025, 0.0752, 0.112, 0.01, 0.0844, 0.0847, 0.0602, 0.087, 0.1145, 0.0671, 0.035, 0.0922, 1.] );  // growth width
          gl.uniformMatrix4fv(params.eta,     false, [0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.] );  // growth strength
          gl.uniformMatrix4fv(params.relR,    false, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.] );  // relative kernel radius
  		break;
  		case 10:
          speciesName = "F45LYC cloud";
  		gl.uniform1f(params.baseNoise, 0.19);
          gl.uniformMatrix4fv(params.betaLen, false, [3., 2., 1., 3., 2., 1., 3., 2., 1., 2., 1., 1., 2., 2., 1., 0.] );  // kernel ring number
          gl.uniformMatrix4fv(params.beta0,   false, [1., 2./3., 1., 1., 5./12., 1., 1., 1./6., 1., 1./6., 1., 1., 7./12., 1./4., 1., 0.] );  // kernel ring heights
          gl.uniformMatrix4fv(params.beta1,   false, [1./4., 1., 0., 1./12., 1., 0., 1./12., 1., 0., 1., 0., 0., 1., 1., 0., 0.] );
          gl.uniformMatrix4fv(params.beta2,   false, [11./12., 0., 0., 2./3., 0., 0., 7./12., 0., 0., 0., 0., 0., 0., 0., 0., 0.] );
          gl.uniformMatrix4fv(params.mu,      false, [0.151, 0.217, 0.249, 0.358, 0.243, 0.463, 0.145, 0.181, 0.31, 0.116, 0.326, 0.68, 0.276, 0.242, 0.119, 0.] );  // growth center
          gl.uniformMatrix4fv(params.sigma,   false, [0.0176, 0.0693, 0.0606, 0.025, 0.0752, 0.112, 0.01, 0.0844, 0.0847, 0.0602, 0.087, 0.1145, 0.0671, 0.035, 0.0922, 1.] );  // growth width
          gl.uniformMatrix4fv(params.eta,     false, [0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.65, 0.] );  // growth strength
          gl.uniformMatrix4fv(params.relR,    false, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.] );  // relative kernel radius
  		break;
  	}
  }

  function init() {
      textbox.innerHTML = "initializing window...";
      if (!gl) {
          alert('Could not initialize WebGL 2.0, try another browser');
          window.location.replace(glNotFoundRedirect);
          return;
      }
      gl.disable(gl.DEPTH_TEST);

      width = canvas.width;
      height = canvas.height;

      canvas.onmousedown = onMouseDown;
      canvas.onmousemove = onMouseMove;
      canvas.onmouseup   = onMouseUp;
      if (window.PointerEvent) {
          canvas.onpointerdown = onMouseDown;
          canvas.onpointermove = onMouseMove;
          canvas.onpointerup   = onMouseUp;
      } else {
          canvas.ontouchstart = onMouseDown;
          canvas.ontouchmove  = onMouseMove;
          canvas.ontouchend   = onMouseUp;
      }

      if (useWindowSize)
          window.onresize = onResize;
      window.onkeypress = onKeyPress;

      textbox.innerHTML = "loading shader files...";
      loadShaderFiles(['vertex.glsl', 'fragment_sim.glsl', 'fragment_draw.glsl', shadertoyFilename],
          initWebGL);
  }

  function initWebGL(shaderSources) {
      textbox.innerHTML = "initializing simulation shader program...";
      var vertexSource = shaderSources[0];
      var simFragmentTemplate = shaderSources[1];
      var drawFragmentSource = shaderSources[2];
      var shadertoySource = shaderSources[3];
      var simFragmentSource = simFragmentTemplate
          .replace("/* Replace shader code here */", shadertoySource)
      //console.log(fragmentShaderSource);

      simProgram = createProgramFromSources(gl, vertexSource, simFragmentSource);
      gl.useProgram(simProgram);

      textbox.innerHTML = "initializing uniform variables...";
      uniforms = {
          iResolution:        gl.getUniformLocation(simProgram, "iResolution"),
          iTime:              gl.getUniformLocation(simProgram, "iTime"),
          iTimeDelta:         gl.getUniformLocation(simProgram, "iTimeDelta"),
          iFrame:             gl.getUniformLocation(simProgram, "iFrame"),
          iChannelTime:       gl.getUniformLocation(simProgram, "iChannelTime"),
          iChannelResolution: gl.getUniformLocation(simProgram, "iChannelResolution"),
          iMouse:             gl.getUniformLocation(simProgram, "iMouse"),
          iChannel0:          gl.getUniformLocation(simProgram, "iChannel0"),
          iChannel1:          gl.getUniformLocation(simProgram, "iChannel1"),
          iChannel2:          gl.getUniformLocation(simProgram, "iChannel2"),
          iChannel3:          gl.getUniformLocation(simProgram, "iChannel3"),
          iDate:              gl.getUniformLocation(simProgram, "iDate"),
          iFrameRate:         gl.getUniformLocation(simProgram, "iFrameRate")
  	};
  	if (initSpecies != null) {
  		params = {
  			//R:                  gl.getUniformLocation(simProgram, "R"),
  			T:                  gl.getUniformLocation(simProgram, "T"),
  			baseNoise:          gl.getUniformLocation(simProgram, "baseNoise"),
  			betaLen:            gl.getUniformLocation(simProgram, "betaLen"),
  			beta0:              gl.getUniformLocation(simProgram, "beta0"),
  			beta1:              gl.getUniformLocation(simProgram, "beta1"),
  			beta2:              gl.getUniformLocation(simProgram, "beta2"),
  			mu:                 gl.getUniformLocation(simProgram, "mu"),
  			sigma:              gl.getUniformLocation(simProgram, "sigma"),
  			eta:                gl.getUniformLocation(simProgram, "eta"),
  			relR:               gl.getUniformLocation(simProgram, "relR")
  		};
  	}

      textbox.innerHTML = "initializing vertex shader...";
      var vertexArray = new Float32Array([
          -1,-1, +1,-1, -1,+1,  // first triangle
          -1,+1, +1,-1, +1,+1   // second triangle
      ]);
      var vertexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertexArray, gl.STATIC_DRAW);

      var a_position = gl.getAttribLocation (simProgram, "a_position");
      gl.activeTexture(gl.TEXTURE0);
      gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(a_position);

      resetTime();
      initUniforms();
      setUniforms();
  	setSpecies(initSpecies);

      onResize();

      textbox.innerHTML = "initializing drawing shader program...";
      drawProgram = createProgramFromSources(gl, vertexSource, drawFragmentSource);
      gl.useProgram(drawProgram);

      var draw_iChannel0 = gl.getUniformLocation(drawProgram, "iChannel0");
      gl.uniform1i(draw_iChannel0, 0);

      textbox.innerHTML = "finish initializing";
      runOnce();
  }

  function makeTexture(gl, width, height, data) {
      var texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, canvasFilter);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, canvasFilter);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, canvasWrap);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, canvasWrap);

      var framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

      return [texture, framebuffer];
  }

  function makeRandomArray(rgba) {
      var numPixels = rgba.length/4;
      var probability = 0.25;
      for (var i=0;i<numPixels;i++) {
          var ii = i * 4;
          var state = Math.random() < probability ? 1 : 0;
          rgba[ii] = rgba[ii + 1] = rgba[ii + 2] = state ? 255 : 0;
          rgba[ii + 3] = 255;
      }
      return rgba;
  }

  function resetTime() {
      gen = 0;
      startTime = new Date();
      lastTime = new Date(startTime);
      lastFPSTime = new Date(startTime);
      lastFPSGen = 0;
  }

  function initUniforms() {
      gl.useProgram(simProgram);
      gl.uniform1i(uniforms.iChannel0, 0);
      gl.uniform1i(uniforms.iChannel1, 1);
      gl.uniform1i(uniforms.iChannel2, 2);
      gl.uniform1i(uniforms.iChannel3, 3);
      gl.uniform1f(uniforms.iSampleRate, 44100.0);
      gl.uniform4f(uniforms.iMouse, 0.0, 0.0, 0.0, 0.0);
  }

  function setUniforms() {
      var now = new Date();
      var year = now.getFullYear();
      var month_minus1 = now.getMonth();
      var day_minus1 = now.getDate() - 1;
      var midnight = new Date(now).setHours(0, 0, 0, 0);
      var seconds = (now - midnight) / 1000;
      var elapsed = (now - startTime) / 1000;
      var delta = (now - lastTime) / 1000;

      var deltaFPSTime = (now - lastFPSTime) / 1000;
      if (gen == 0)
          actualFPS = 0;
      else if (deltaFPSTime >= 3) {
          actualFPS = (gen - lastFPSGen) / deltaFPSTime;
          lastFPSTime = now;
          lastFPSGen = gen;
      }

      gl.useProgram(simProgram);
      gl.uniform1i(uniforms.iFrame, gen);
      gl.uniform1f(uniforms.iTime, elapsed);
      gl.uniform1fv(uniforms.iChannelTime, [elapsed, elapsed, elapsed, elapsed]);
      gl.uniform1f(uniforms.iTimeDelta, delta);
      gl.uniform4f(uniforms.iDate, year, month_minus1, day_minus1, seconds);
      gl.uniform1f(uniforms.iFrameRate, actualFPS);

      lastTime = now;
  }

  function runOnce() {
      if (!pause) {
          gl.useProgram(simProgram);
          setUniforms();

          for (var step = 0; step < stepsPerFrame; step++) {
              frameFlip = !frameFlip;
              // read from frame (as texture), calculate and render to alternate frame (as framebuffer)
              gl.bindTexture(gl.TEXTURE_2D, frameFlip ? textureA : textureB);
              gl.bindFramebuffer(gl.FRAMEBUFFER, frameFlip ? framebufferB : framebufferA);
              gl.drawArrays(gl.TRIANGLES, 0, 6);
              gen++;
          }

          // render the latest frame (as texture) to canvas (as framebuffer)
          gl.useProgram(drawProgram);
          gl.bindTexture(gl.TEXTURE_2D, frameFlip ? textureB : textureA);
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          gl.drawArrays(gl.TRIANGLES, 0, 6);
          frame++;

          var status = width + "x" + height + " " + actualFPS.toFixed(1) + "fps";
          if (filename == "lenia4param") status += "</br>" + speciesName;
          textbox.innerHTML = status;
      }

      window.requestAnimationFrame(runOnce);
      //window.setTimeout(() => { window.requestAnimationFrame(runOnce) }, 1000/targetFPS);
  }

  function onResize(e) {
      if (!gl) return;

      if (useWindowSize) {
          width = Math.floor(canvas.clientWidth / pixelSize);
          height = Math.floor(canvas.clientHeight / pixelSize);
          canvas.width = width;
          canvas.height = height;
      } else {
          width = canvas.width;
          height = canvas.height;
          canvas.style.width = Math.ceil(width * pixelSize) + "px";
          canvas.style.height = Math.ceil(height * pixelSize) + "px";
      }

      //var newArray = new Uint8Array(width * height * 4);
      [textureA, framebufferA] = makeTexture(gl, width, height, null);  // makeRandomArray(newArray)
      [textureB, framebufferB] = makeTexture(gl, width, height, null);

      gl.viewport(0, 0, width, height);

      const ratio = 1.0;
      gl.useProgram(simProgram);
      gl.uniform2f(uniforms.iResolution, width, height);
      gl.uniform3fv(uniforms.iChannelResolution, [width,height,ratio, width,height,ratio, width,height,ratio, width,height,ratio]);

      resetTime();
  }

  function onKeyPress(e) {
      switch (e.key) {
          case " ": pause = ! pause; break;
      }
      switch (e.keyCode) {
          case 13: gen = 0; break;
      }
  }

  var isMouseDown = false;
  function set_iMouse(e, sx, sy) {
      var x = e.clientX / pixelSize;
      var y = height - e.clientY / pixelSize;
      gl.useProgram(simProgram);
      gl.uniform4f(uniforms.iMouse, x, y, sx*x, sy*y);
  }
  function onMouseDown(e) { isMouseDown = true;  set_iMouse(e, +1, +1); }
  function onMouseMove(e) { if (isMouseDown)     set_iMouse(e, +1, -1); }
  function onMouseUp  (e) { isMouseDown = false; set_iMouse(e, -1, -1);
  	randomSpecies = Math.floor(new Date().getSeconds() / 60 * 10); //Math.floor(Math.random() * 9);
  	initSpecies = getParam("species", "int", randomSpecies, randomSpecies);
  	setSpecies(initSpecies);
  }

  </script>

  <img src="demo.gif" alt="demo GIF" width="100%" class=l-middle-outset>
  <dt-byline></dt-byline>




  <p>Spatially localized patterns in cellular automata have shown a lot of interesting behavior that led to new understanding of self-organizing system. While the notion of environment is a keypoint in Maturana and Varela biology of cognition, studies on cellular automata rarely introduced a well defined environment in their system. In this paper, we propose to add walls in a cellular automata to study how we can learn a self-organizing creature capable of reacting to the perturbations induced by the environment, ie robust creatures with sensorimotor capabilities. We provide a method based on curriculum learning able to learn the CA rule leading to such creature. The creature obtained,using only local update rules, are able to regenerate and preserve their individuality and structure while dealing with the obstacles in their way..</p>



  <!--
  <d-contents>
  <nav class="l-gutter text figcaption">
    <h4>Contents</h4>
    <h6><a href="#introduction">Introduction</a></h6>
    <h6><a href="#system">the system</a></h6>
    <h6><a href="#movingCrea">Learning Moving Creature in Lenia</a></h6>
    <h6><a href="#robustCrea">Learning robust creatures with sensorimotor capabilities</a></h6>
    <h6><a href="#results">Results</a></h6>
    <h6><a href="#discussion">Discussion</a></h6>
  </nav>
  </d-contents>
  -->

  <h2 id="introduction">Introduction</h2>
  <p>
     In Maturana and Varela work <dt-cite key="VarelaThompsonEmbo"></dt-cite>, cognition is centered around how an agent "reacts" to the perturbation induced by it's environment . More precisely, they introduce the notion of cognitive domain of a self-organizing system which are all the perturbations induced by the environment which do  not result in the destruction of the self-organizing system. Their notion of cognition is thus deeply linked with how a self-organizing creature will try to preserve its integrity in its environment. ("living is ")
  </p>

  <p>
      From their theories, studies has been made to apply those notion to examples of self-organizing systems. For example, the game of life and especially the glider has been studied under their paradigm <dt-cite key="PMID:24494612"></dt-cite> showing again the richness and complexity of such system. However, even if the glider in the game of life has shown to be a good toy model to explicit those theories with interesting interaction, they're also quite simple entity that are not very robust, with a lot of perturbation leading to destruction. (Also in those work, the environment wasn't well defined like walls food etc, but rather other structure.)
  </p>

  <p>
    In biology, We also find sensorimotor capabilities at the macro scale for example in swarm of  bacteria <dt-cite key="PhysRevE.101.012407"></dt-cite>  where a group of bacteria seem to avoid a wall of antibiotics. group decision making for obstacle avoidance
  </p>

  <p>
    Other studies, taking inspiration from biological regrowth in some animals, focused on the recovery from Deformation/ damage  <dt-cite key="horibe2021regenerating"></dt-cite> <dt-cite key="mordvintsev2020growing"></dt-cite>, applying Cellular automata to build and regenerate damaged parts.
  </p>
  <p>
    IN Lenia <dt-cite key="chan2020lenia"></dt-cite> <dt-cite key="chan2019lenia"></dt-cite> , we can see some sort of sensorimotor capabilities. However, even if there are interaction between some entity, there is no well define environment. The search for new creature in Lenia was first done manually testing parameters and mutating it or with simple evolutionary algorithm for moving creature for example. Other studies <dt-cite key="etcheverry2020hierarchically"></dt-cite>  <dt-cite key="reinke2020intrinsically"></dt-cite> focused on exploring as much as possible the space of creature in Lenia using intrinsically motivated explorer  . However this last techniques had a hard time finding moving creature.
  </p>

  <p>
    In cellular automata, what's interesting is that we have the same local update rule  applied to every cell (no cell has a special role ), yet it allows to have very complex self organizing structure. In this work, we'll show how to learn the Ca update rule leading to robustness and sensorimotor capabilities with walls. The creature we obtain, from the deformation induced by the walls on some part of it make new deicision at the macro level on where to go/how to react. What's even more interesting is that the computation made for the decision are all made in the creature itself, at the morphology level. (Each cell then from its neighboors know what it should do.)
  </p>

  <p>
    In this work, we
    no well define environment and creature obtained by luck and not very robust.
    swarm robotics ?
  </p>






  <dt-byline></dt-byline>
  <h2 id="system"> The system </h2>
  <img src="LeniaWall.png" alt="scheme" width="100%" >


  <h4> Lenia </h4>
  <p>
     The cellular automaton we will study in this work is Lenia <dt-cite key="chan2020lenia"></dt-cite><dt-cite key="chan2019lenia"></dt-cite>. Lenia is a system of continous cellular automata where a wide variety of complex behavior has already been osberved, including what looks like sensorimotor-capabilities. In this work i will use the multi channel, multi kernel version of Lenia <dt-cite key="chan2020lenia"></dt-cite> but for simplicity we will only use 1 channel for the creature and other ones for the environment.
  </p>
  <p>
     A Lenia system like all CA starts from an initial pattern and iteratively update every pixel based on its neihgbours. The CA rule is given by the kernels and associated growth map.
  </p>




  <h4> Walls </h4>
  <p>
  To implement walls in Lenia we simply added a walls channels with a kernel from the wall channel to the creature channel. This kernel have a huge negative growth where there are walls and no impact on other pixels where there are no walls. This way we prevent any growth in the pixels where there are walls. This is  similar to  <dt-cite key="PhysRevE.101.012407"></dt-cite> where they put antibiotic zone as obstacle where the bacteria can't live. The creature can only sense the wall through the changes/deformations it implies on the creature, so the creature has to "touch" the wall to sense it. (But because of the cellular automaton nature of the creature the information  has to be transmitted to other cells.)
  </p>

  <p>
  Note that we used kernel for the walls so that the system stays under the Lenia paradigm using local kernels only  for the updates.
  </p>
  <p>
    In this study, the creature can't have any impact on the walls. This differs from other studies such as <dt-cite key="PMID:24494612"></dt-cite> in the game of life where the creature also perturb it's environment.
  </p>
  <p>
      Glider type of creature has been found in 1 channel lenia. However, they're not very robust to walls as shown here:
  </p>
  <div class="row l-body">
  <div class="column">
    <img src="orbium.gif" alt="demo GIF" width="85%" >
  </div>
  <div class="column">
    <img src="orbiumb.gif" alt="demo GIF" width="85%" >
  </div>
  </div>


  <h4> Differentiable Lenia </h4>
  <p>
      Now that the environment is defined, we want to learn both the initialization and the CA rules leading to interesting behaviors. All parameters of the CA rule will be optimized, as well as the initialization which will be a square of fixed size.( each pixel will have its value optimized)
  </p>

  <p>
      To learn these parameters we chose to use gradient descent method. Thus we tried to make Lenia as Differentiable friendly as possible. To do so, the main shift is to use "free kernels", using kernels in the form of a sum of n overlapping gaussian bumps: $$x \rightarrow \sum_i^{n} b_i exp(-\frac{(x-rk_i)^2}{w_i}) $$. The parameters are then 3  n dimensional vectors: b for height of the bump, w for the size of the bump and rk for the center of the bump.
  </p>

  <img src="freeK.png" alt="schemeK" width="100%" class='l-body' >
  <p>
    We did this shift because in the vanilla version of Lenia, the shape of the kernel was only given by a vector b of arbitrary size (but often max size 4). The number of bumps was given by the number of coefficient in b>0. However, the fact that the number of bumps depends on the number of coefficient > 0 prevents proper differentiation.
(if a coefficient is at 0 then it won't change with gradient descent as it doesn't play a role, and if a coefficient is >0 a gradient step can put it <0 which will make a strong unexpected change). We could have left the number of bumps to an arbitrary value like 3, and only optimizing the height such as they stay >0  but this would have been a strong limitation on the shape. The "free kernels", in addition to differentiation, allow more flexibility than the vanilla bumps but at the cost of more parameters.
  </p>
  <p>
  However even doing so, differentiating through Lenia can be difficult because we often have quite a big number of iterations and each iteration has it's result clipped between 0 and 1.
  </p>







  <h2 id="movingCrea">Learning Moving Creature in Lenia</h2>

  <p>
    Before trying to find sensorimotor capabilities in our system a first step would be to find moving creatures like glider in the game of life. Note that moving creature in cellular automaton differ from other type of movement like muscle contraction or soft robot (article) by the fact that moving is growing at the front and dying at the back.
   In this paper, we learn to develop morphology and motricity at the same time. The CA rule will both be applied to grow the creature from an initial state and be the "physics" that makes it move.
 </p>

 <p>
    Target image with MSE error seems effective to learn CA rule leading to certain pattern <dt-cite key="mordvintsev2020growing"></dt-cite>. ANd the fact that it's a very informative loss, thus helping with vanishing gradient problem made us choose this loss for our problem over other losses such as maximizing the coordinate of the center of mass . THe first target shape we tried was a single disk. However after seeing the robust creature obtained with this disk as target  seemed to have a "core" and a shallow envelopp, we informally chose to move to two superposed disk, a large shallow one with a thick smaller one on top. The target shape has the formula:   \(0.1*(R<1)+0.8*(R<0.5)\). We chose on purpose to have the sum to be smaller than 1 because as we clip to 1 the pixel after each update it/s  better to have pixel below 1 than pixel saturated if you want to have gradients.
 </p>

 <p>
   However simply putting a target shape far from initialization and optimize towards it does not work most of the times. In fact,  it works only when the target is not too far from where the creature ended before optimization (so after the random initialization) . This comes from the fact that applying a lot of steps, each clipped, prevents gradient from flowing. The solution we propose to go further than this is curriculum learning.

 </p>




 <h4>IMGEP and Utility of curriculum</h4>
<img src="IMGEP.svg" alt="IMGEPscheme" width="100%" class="l-middle-outset">
 <p>
   In fact, once we obtain a creature able to go a little further than the initialisation, we can push the target a little bit and learn to attain it. This time the new target needs to overlap where the creature is able to go  after the first optimisation. Then we just need to iterate this process. SCHEME
 </p>

 <p>
   The effectiveness of curriculum with complex task has already been shown in <dt-cite key="DBLP:journals/corr/abs-1901-01753"></dt-cite>. And in complex self organizing systems in <dt-cite key="variengien2021selforganized"></dt-cite>

 </p>

 <p>
   One modular way we introduced it was using IMGEP <dt-cite key="Forestier2017IntrinsicallyMG"></dt-cite>  which has already been used as an explorative tool in Lenia to explore the morphological space <dt-cite key="etcheverry2020hierarchically"></dt-cite> <dt-cite key="reinke2020intrinsically"></dt-cite>.

 </p>

 <p>
   The general idea of IMGEP is to iteratively set new goals to achieve  and for each of these goals try to learn a policy that would suit this goal. THis way an IMGEP needs an interesting way to sample new goal for example based on intrinsic reward. It also needs a way to track the progress on this goal, and a way to optimize toward this goal. It also might use the knowledge acquired on other goals to learn new goals or attain them more quickly.

 </p>
 <dt-code block="" language="python" class="l-gutter">
    <p>def update(perception_vector):</p>
    <p># The following pseudocode operates on</p>
    <p># a single cell’s perception vector.</p>
    <p># Our reference implementation uses 1D</p>
    <p># convolutions for performance reasons.</p>
    <p>x = dense(perception_vector, output_len=128)</p>
    <p>x = relu(x)</p>
    <p>ds = dense(x, output_len=16, weights_init=0.0)</p>
    <p>return ds</p>
  </dt-code>
 <p>
   In our case, the goal space will simply be a 2 dimensional vector representing the position of the center of mass of the creature at last timestep. The way we sample the goals depends on the task but to have a moving creature that goes far in the grid, we will randomly sample position in the grid biasing the sampling toward one edge of the grid. we use MSE error between the last state and our target shape centered at the target goal to try to achieve this goal. The way we reuse knowledge acquired is by intializing the parameters by the one that achieve the closest goal.
 </p>




 <h2 id="robustCrea"> Learning robust creatures with sensorimotor capabilities </h2>
 <img src="merge.png" alt="schemeLearn" width="100%" class="l-middle-outset" >
 <p >
  Initialization is the yellow square; Left: reached goal library in green, target goal in read. THe policy selected is the one reaching the position in purple circle; Right:  Blue is the obstacle, red the target shape and green the creature before optimisation at last timestep. Green dashed line is at the same position in both.
 </p>

 <p>
  Now that we have an algorithm that is capable of learning moving creature in Lenia. the next step is to find a way to learn a creature that would resist and avoid obstacles in its environment, using the deformations the environment induces on it to sense. In this section, we'll try from scratch to learn a single CA rule and initialization that lead to building, moving and regenerating creature. So we will learn a single global rule for multiple functions contrary to  <dt-cite key="horibe2021regenerating"></dt-cite> which separates regenerating and building into two different CA.
 </p>

 <p>
  What we want to obtain is a creature that is able to generalize to different obstacles. To do so we will train the creatures on randomly generated obstacles. This way our gradient descent will be stochastic gradient descent with the stochasticity coming from the sampling of the obstacles. The learning process will thus encounter a lot of different configurations and may find general behavior. In practice, we will only put obstacles in half the lattice grid. This way, there will be half of the grid free from obstacle where we will first learn a creature that is able to move without any perturbation as in previous section and then as we push the target further and further the creature will start to encounter obstacles. And the deeper the target position is, the more it will encounter obstacles  and so the more it should be robust. In fact at the beginning you will just be a little perturbed by one obstacle and the target circle will optimize the creature to get past the obstacle and recover. (scheme) Then if you want the creature to go further it will have to encounter more obstacles and still be able to resist the second one even if the first one perturbed it. See appendix for more details on the obstacles.
 </p>
 <p>
  In the IMGEP, to take into account the fact that the position attained depends on the obstacle configuration, the reached goal will be an average of the position attained on different configurations of obstacles.
 </p>
<h3>Overcoming "bad initialization" problem </h3>
 <p>
  While training with this algorithm sometimes the optimisation could not get creature getting passed the obstacles because of the initialization and creature that were obtained from the initialization were not "good" enough. This can be mitigated by adding random mutations before optimizing. It may unstuck the situation however the creature after mutation are often not that good and most of the time far from the target goal (because mutation often make "suboptimal" creature that may be slower than the one before mutation) which prevent learning. So mutation can help unstuck situation but also slows the training. This is why we loop until we fight good mutation meaning mutation that don't kill or explode the creature and also why we apply less optimization steps for the mutated one, see appendix for more details.
 </p>

 <p>
   This does not solve the problem 100\% of the time and that's why we also apply initialization selection. We run deterministic first steps (fixed target position), until we find an initialization which gives a good loss for the 3 first  deterministic target.
 </p>




<h2 id="results"> Results </h2>
 <p>
   The resulting creature are very robust to walls perturbations and able to navigate in difficult environment. In fact, even if the creature were only trained for 50 timesteps in the system and few circle obstacles, the resulting creature seem to be long term stable and able to recover from perturbation induced by various shape of wall including vertical walls. One very surprising emerging behavior is that the creature is sometimes able to come out of dead end showing how well this technique generalizes. There are still some failure cases, with creature obtained that can get unstable after some perturbation, but the creature are most of the time robust to a lot of different obstacles.
 </p>


 <h3> Study of the creatures </h3>
 <p>
   What's interesting in such system is that the computation of decision, is all done at the macro (group) level showing how a group of simple identical entities through local interactions can make "decision", sense at the macro scale. Seeing these creature it's even hard to believe that they are in fact made of tiny part all behaving under the same rules.
 </p>
 <p>
   In fact in order to navigate, first it need to sense the wall through a deformation of itself. Then after this deformation it has to make a collective "decision" on where to grow next and then move and regrow it's shape.
 </p>
 <p>
   After visualizing the kernels and doing informal ablation studies it seems that the creature we obtain have "limiting growth" kernel that tries to prevent the creature from growing too much beyond its boundaries and also growth kernel. Those two type of kernel are in equilibrium but We can play with the weight of each kernel  a little bit without destroying this equilibrium. For example the main utility we found of this is that "limiting growth" kernels can be given more importance to enforce the individuality of the creature and prevent several creature colliding from merging (see next section) because it gives stronger boundaries. However putting too much weight on those limiting kernels can lead to creature dying from too much damage as you inhibit growth.
 </p>

 <p>
   Surprisingly some creature looked a lot like creature from <dt-cite key="chan2019lenia"></dt-cite> which were obtained by evolutionary algorithm or by hand made mutations.
 </p>


<h3>Multi creature setting</h3>
 <p>
  By adding more initialization square in the grid, we can add several creature with the same update rule. As pointed out in <dt-cite key="PMID:24494612"></dt-cite>, other entity are also part of the environment for the creature and can give rise to nice interactions. Maturana and Varela even refer to this kind of interaction as communication.
 </p>


<img src="demo.gif" alt="repro GIF" width="50%" class="l-body">
 <p>
   The creature obtained shows strong individuality preservation. In fact, creatures goes in non destructive interactions most of the times without merging. As said before, we can tune the weight of the kernels (especially the limiting growth one to make the merge of two creature harder. By increasing those limiting growth kernels, the repeal of two entities get stronger and they will simply change direction.
 </p>

 <p>
   One other type of interaction between two creature of the same species(governed by the same update rule/physic) is creature getting stuck together. The two creatures when they collide are stuck together going in the same direction. However even when they're stuck together, from a human point of view seeing this system, we ce can still see 2 distinct creatures.This type of behavior is  studied in the game of life in <dt-cite key="PMID:24494612"></dt-cite>  with the notion of consensual domain.
 </p>
<img src="repro.gif" alt="repro GIF" width="50%" class="l-body">
 <p>
   Another interesting interaction we observed during colision was "reproduction". In fact for some collision, we could observe the birth of a 3rd entity. This kind of interaction seemed to happen when one of the two entity colliding was in a certain "mode" like when it just hit a wall. Our intuition is that when it hits a wall, it has to have a growth response in order to recover. And during this growth response if we add some perturbation of another entity it might separate this growth from the entity and then this separated mass from strong self-organization grows into a complete individual.
 </p>


<h3>Different target shape</h3>

 <p>
   To try to have more diversity in the morphology of the creature we tried to change the target shape. In fact as the creature is optimized to fit this shape at the last timestep we can expect that changing this shape may lead to other morphologies.
 </p>

 <p>
   However we tried with half circle, star and sharp star without success. For all of these shape we still obtained roundish morphologies. This may be due to the kernel shape which bias the shape of the creature. However as shown in the appendix, we can optimize the growth toward a complicated gecco shape. The failure of these optimisation may be due to the difficulty added by the fact that we want a moving creature.Thus When we optimize the MSE loss, before trying to make this complicated shape the optimization first learns to get the creature to where it should be, and trying to grow it into this star shape may not be well aligned with this.
 </p>
<img src="2circlewall.gif" alt="demo GIF" width="100%" class=l-body>
 <p>
   We still tried to have roundish shape different from a single disk. For example we put as our target 2 disk target(defined \ref{}) close, overlapping a little bit. And the creature it produced was a creature seemingly composed of two roundish creature stuck together. But the force of their attraction is quite big as even when one of the creature collide an obstacle, they keep being stuck. And even when they seem to separate from a collision with an obstacle, they each independently follow the obstacle until they merge again.(However we can see at the end of the clip that they start to explode at the end) This type of behavior might be hard to get from random exploration as small mutation on the CA rule easily break this attraction leading to 2 separate creature going their own way from initialization or even worse lead to repealing creature.
 </p>






 <h2 id="discussion"> Discussion </h2>

 <p>
    Surprising to see that the creature is able to do all the computation required for changing direction in itself.
 </p>

 <p>
   radius is quite big while \cite{mordvintsev2020growing} Moore neighbourhood size 3. (but no hidden channel)
   Even if this, this work still provides interesting idea on how to learn parameters in complex systems that can be very sensitive, especially how to deal with certain problems such that vanishing gradient, bad initialization.

 </p>

 <p>
   food?
   discussion difficulty coming from other agents becoming stronger competition in evolution/\cite{baker2020emergent}). Future work might use these creature as basis for species mutate them and make them compete for food.
 </p>





</dt-article>

<dt-appendix>

  <h3> Breeding and mutation </h3>
  <h3> Food </h3>
  <video id="model-editing-level-1-video-1" controls="" muted="">
                <source src="demoFoodc.mp4" type="video/mp4">
              </video>
</dt-appendix>

<script type="text/bibliography">
  @article{DBLP:journals/corr/abs-1901-01753,
  author    = {Rui Wang and
               Joel Lehman and
               Jeff Clune and
               Kenneth O. Stanley},
  title     = {Paired Open-Ended Trailblazer {(POET):} Endlessly Generating Increasingly
               Complex and Diverse Learning Environments and Their Solutions},
  journal   = {CoRR},
  volume    = {abs/1901.01753},
  year      = {2019},
  url       = {http://arxiv.org/abs/1901.01753},
  archivePrefix = {arXiv},
  eprint    = {1901.01753},
  timestamp = {Tue, 29 Sep 2020 10:47:58 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/abs-1901-01753.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
  }

  @article{autopoiesisBeer2004,
    author    = {Randall D. Beer},
    title     = {Autopoiesis and Cognition in the Game of Life.},
    journal   = {Artif Life},
    volume    = {10(3)},
    year      = {2004},
    url       = { https://doi.org/10.1162/1064546041255539},

  }


  @misc{chan2020lenia,
        title={Lenia and Expanded Universe},
        author={Bert Wang-Chak Chan},
        year={2020},
        eprint={2005.03742},
        archivePrefix={arXiv},
        primaryClass={nlin.CG}
  }

  @misc{chan2019lenia,
        title={Lenia - Biology of Artificial Life},
        author={Bert Wang-Chak Chan},
        year={2019},
        eprint={1812.05433},
        archivePrefix={arXiv},
        primaryClass={nlin.CG}
  }

  @article{mordvintsev2020growing,
    author = {Mordvintsev, Alexander and Randazzo, Ettore and Niklasson, Eyvind and Levin, Michael},
    title = {Growing Neural Cellular Automata},
    journal = {Distill},
    year = {2020},
    note = {https://distill.pub/2020/growing-ca},
    doi = {10.23915/distill.00023}
  }

  @misc{etcheverry2020hierarchically,
        title={Hierarchically Organized Latent Modules for Exploratory Search in Morphogenetic Systems},
        author={Mayalen Etcheverry and Clement Moulin-Frier and Pierre-Yves Oudeyer},
        year={2020},
        eprint={2007.01195},
        archivePrefix={arXiv},
        primaryClass={cs.LG}
  }

  @misc{reinke2020intrinsically,
        title={Intrinsically Motivated Discovery of Diverse Patterns in Self-Organizing Systems},
        author={Chris Reinke and Mayalen Etcheverry and Pierre-Yves Oudeyer},
        year={2020},
        eprint={1908.06663},
        archivePrefix={arXiv},
        primaryClass={cs.LG}
  }

  @misc{horibe2021regenerating,
        title={Regenerating Soft Robots through Neural Cellular Automata},
        author={Kazuya Horibe and Kathryn Walker and Sebastian Risi},
        year={2021},
        eprint={2102.02579},
        archivePrefix={arXiv},
        primaryClass={cs.NE}
  }

  @misc{sudhakaran2021growing,
        title={Growing 3D Artefacts and Functional Machines with Neural Cellular Automata},
        author={Shyam Sudhakaran and Djordje Grbic and Siyan Li and Adam Katona and Elias Najarro and Claire Glanois and Sebastian Risi},
        year={2021},
        eprint={2103.08737},
        archivePrefix={arXiv},
        primaryClass={cs.LG}
  }

  @misc{baker2020emergent,
        title={Emergent Tool Use From Multi-Agent Autocurricula},
        author={Bowen Baker and Ingmar Kanitscheider and Todor Markov and Yi Wu and Glenn Powell and Bob McGrew and Igor Mordatch},
        year={2020},
        eprint={1909.07528},
        archivePrefix={arXiv},
        primaryClass={cs.LG}
  }

  @article{PhysRevE.101.012407,
    title = {Active modulation of surfactant-driven flow instabilities by swarming bacteria},
    author = {Kotian, Harshitha S. and Abdulla, Amith Z. and Hithysini, K. N. and Harkar, Shalini and Joge, Shubham and Mishra, Ayushi and Singh, Varsha and Varma, Manoj M.},
    journal = {Phys. Rev. E},
    volume = {101},
    issue = {1},
    pages = {012407},
    numpages = {10},
    year = {2020},
    month = {Jan},
    publisher = {American Physical Society},
    doi = {10.1103/PhysRevE.101.012407},
    url = {https://link.aps.org/doi/10.1103/PhysRevE.101.012407}
  }



  @misc{barnett2021dynamical,
        title={Dynamical independence: discovering emergent macroscopic processes in complex dynamical systems},
        author={Lionel Barnett and Anil K. Seth},
        year={2021},
        eprint={2106.06511},
        archivePrefix={arXiv},
        primaryClass={nlin.AO}
  }
  @misc{krakauer2020information,
        title={The Information Theory of Individuality},
        author={Krakauer, D., Bertschinger, N., Olbrich, E. et al.},
        year={2020},
        journal = {Theory Biosci},
        volume = {139,},
        pages = {209–223},

  }

  @article{Beer2015CharacterizingAI,
    title={Characterizing Autopoiesis in the Game of Life},
    author={R. Beer},
    journal={Artificial Life},
    year={2015},
    volume={21},
    pages={1-19}
  }

  @article {PMID:24494612,
  	Title = {The cognitive domain of a glider in the game of life},
  	Author = {Beer, Randall D},
  	DOI = {10.1162/artl_a_00125},
  	Number = {2},
  	Volume = {20},
  	Year = {2014},
  	Journal = {Artificial life},
  	ISSN = {1064-5462},
  	Pages = {183—206},
  	Abstract = {This article examines in some technical detail the application of Maturana and Varela s biology of cognition to a simple concrete model: a glider in the game of Life cellular automaton. By adopting an autopoietic perspective on a glider, the set of possible perturbations to it can be divided into destructive and nondestructive subsets. From a glider s reaction to each nondestructive perturbation, its cognitive domain is then mapped. In addition, the structure of a glider s possible knowledge of its immediate environment, and the way in which that knowledge is grounded in its constitution, are fully described. The notion of structural coupling is then explored by characterizing the paths of mutual perturbation that a glider and its environment can undergo. Finally, a simple example of a communicative interaction between two gliders is given. The article concludes with a discussion of the potential implications of this analysis for the enactive approach to cognition.},
  	URL = {https://doi.org/10.1162/ARTL_a_00125},
  }

  @article{Forestier2017IntrinsicallyMG,
    title={Intrinsically Motivated Goal Exploration Processes with Automatic Curriculum Learning},
    author={Sebastien Forestier and Yoan Mollard and Pierre-Yves Oudeyer},
    journal={ArXiv},
    year={2017},
    volume={abs/1708.02190}
  }
  @book{VarelaThompsonEmbo,
    title={The embodied mind.},
    author={Varela ,F. J. and Thompson, E., and Rosch, E.},
    year={1991}

  }

  @misc{variengien2021selforganized,
      title={Towards self-organized control: Using neural cellular automata to robustly control a cart-pole agent},
      author={Alexandre Variengien and Stefano Nichele and Tom Glover and Sidney Pontes-Filho},
      year={2021},
      eprint={2106.15240},
      archivePrefix={arXiv},
      primaryClass={cs.NE}
}
</script>
